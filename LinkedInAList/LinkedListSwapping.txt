Skip to Content

Avatar
Swapping Elements in a Linked List
Learn how to swap two nodes in a singly linked list in Python.

Since singly linked lists only have pointers from each node to its next node, swapping two nodes in the list isn‚Äôt as easy as doing so in an array (where you have access to the indices). You not only have to find the elements, but also reset their surrounding pointers to maintain the integrity of the list. This means keeping track of the two nodes to be swapped as well as the nodes preceding them.

Given a linked list and the elements to be swapped (val1 and val2), we need to keep track of four values:

node1: the node that matches val1
node1_prev: node1‚Äòs previous node
node2: the node that matches val2
node2_prev: node2‚Äòs previous node
Given an input of a linked list, val1, and val2, the general steps for doing so is as follows:

Iterate through the list looking for the node that matches val1 to be swapped (node1), keeping track of the node‚Äôs previous node as you iterate (node1_prev)
Repeat step 1 looking for the node that matches val2 (giving you node2 and node2_prev)
If node1_prev is None, node1 was the head of the list, so set the list‚Äôs head to node2
Otherwise, set node1_prev‚Äòs next node to node2
If node2_prev is None, set the list‚Äôs head to node1
Otherwise, set node2_prev‚Äòs next node to node1
Set node1‚Äòs next node to node2‚Äòs next node
Set node2‚Äòs next node to node1‚Äòs next node
Finding the Matching and Preceding Nodes
Let‚Äôs look at what implementing steps 1 and 2 looks like. In order to swap the two nodes, we must first find them. We also need to keep track of the nodes that precede them so that we can properly reset their pointers. (We will use the Node class‚Äôs .get_next_node() method in order to access the next node.)

We will start by setting node1 equal to the head of the list, and then creating a while loop that runs while node1 isn‚Äôt None. Inside the loop, we will check if node1‚Äòs value matches val1. If so, we break out of the loop as we have found the correct node. If there is no match, we update node1_prev to be node1 and move node1 to its next node:

def swap_nodes(input_list, val1, val2):
  node1 = input_list.head_node
  node2 = input_list.head_node
  node1_prev = None
  node2_prev = None
 
  while node1 is not None:
    if node1.get_value() == val1:
      break
    node1_prev = node1
    node1 = node1.get_next_node()
At the end of this, we have found our matching node, and also saved its previous node, which we will use in the next step.

Fill in the code to complete the while loop that will find node2 and node2_prev.

while node2 is not None:
  if node2.get_value() == val2:
    break
  node2_prev = node2
  node2 = node2.get_next_node()

üëè
You got it!
Updating the Preceding Nodes‚Äô Pointers
Our next step is to set node1_prev and node2_prev‚Äòs next nodes, starting with node1_prev. We‚Äôll begin by checking if node1_prev is None. If it is, then the node1 is the head of the list, and so we will update the head to be node2. If node1_prev isn‚Äôt None, then we set its next node to node2:

# Still inside the swap_nodes() function
if node1_prev is None:
  input_list.head_node = node2
else:
  node1_prev.set_next_node(node2);
After this step, we have finished updating the pointers that point to our swapped nodes. The next step will be to update the pointers from them.

Fill in the code to update node2_prev‚Äòs next node.

if node2_prev is None:
  input_list.head_node = node1
else:
  node2_prev.set_next_node(node1)

üëè
You got it!
Updating the Nodes‚Äô Next Pointers
The last step is to update the pointers from node1 and node2. This is relatively simple, and mirrors a swapping function for an array in that we will use a temporary variable.

Fill in the code to set node1 and node2‚Äòs next nodes.

temp = node1.get_next_node()
node1.set_next_node(node2.get_next_node())
node2.set_next_node(temp)

üëè
You got it!
Edge Cases
We have completed the basic swap algorithm in Python! However, we haven‚Äôt accounted for some edge cases. What if there is no matching node for one of the inputs? The current swap_nodes() function will not run because we will try to access the next node of a node that is None. (Remember that our initial while loop only breaks if the matching node is found. Otherwise, it runs until the node is None.)

Thankfully this has a quick fix. We can put in an if that checks if either node1 or node2 is None. If they are, we can print a statement that explains a match was not found, and return to end the method. We can put this right after the while loops that iterate through the list to find the matching nodes:

if (node1 is None or node2 is None):
  print("Swap not possible - one or more element is not in the list")
  return
The last edge case is if the two nodes to be swapped are the same. While our current implementation will run without error, there‚Äôs no point in executing the whole function if it isn‚Äôt necessary. We can add a brief check at the beginning of the function that checks if the val1 is the same as val2, and then return to end the function:

if val1 == val2:
  print("Elements are the same - no swap needed")
  return

The Finished Function
Below is the final .swap_nodes() function. Run it to see how it works. Does it work with edge case inputs?

38394041424344454647484950515253
  else:
    node2_prev.set_next_node(node1)

  temp = node1.get_next_node()
  node1.set_next_node(node2.get_next_node())
  node2.set_next_node(temp)


ll = LinkedList.LinkedList()

Output:
9
8
7
6
5
4
3
2
1
0

Swapping 9 with 5
5
8
7
6
9
4
3
2
1
0

 
üëè
You got it!
Time and Space Complexity
The worst case for time complexity in swap_nodes() is if both while loops must iterate all the way through to the end (either if there are no matching nodes, or if the matching node is at the tail). This means that it has a linear big O runtime of O(n), since each while loop has a O(n) runtime, and constants are dropped.

There are four new variables created in the function regardless of the input, which means that it has a constant space complexity of O(1).

Back
Next